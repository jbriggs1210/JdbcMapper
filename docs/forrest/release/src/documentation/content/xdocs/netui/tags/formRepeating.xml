<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN"
	"http://forrest.apache.org/dtd/document-v20.dtd">
<document>
    <header>
        <title>NetUI Repeating Form Control Tags</title>
    </header>
    <body>
        <section id="Intro">
            <title>Introduction</title>
            <p> The three NetUI group tags offer a repeating mode that increases the control
                the developer has over their output.  For the <code>&lt;netui:checkBoxGroup></code>
                and the <code>&lt;netui:radioButtonGroup></code> tags the control extends to the layout of the resulting
                markup.  For the <code>&lt;netui:select></code> tag the developer can control the order of
                the options and the <code>value</code> and <code>label</code> when an <code>optionsDataSource</code>
                is being used.
            </p>
            <p> This is an advanced tag topic.  For more information on the basic operations of these tags
                see the <a href="site:pageflow_tag_formControls">NetUI Form Control Tags</a> topic.
            </p>
        </section>
        <section id="GroupTags">
            <title>CheckBoxGroup and RadioButtonGroup</title>
            <p>This section demonstrates how to control the markup generated by both the <code>&lt;netui:checkBoxGroup></code>
                and <code>&lt;netui:radioButtonGroup></code> tags.  Both tags have an attribute <code>repeater</code>
                which, when set to <code>true</code>, turns the tag into a repeating tag.  The tag will then loop
                over each element found in the <code>optionsDataSource</code> and evaluate the tag's body against the item.
                Before the body is evaluated, the implicit object <code>container</code> is setup.  For more
                information see the <a href="site:databinding_container">data binding container implicit object</a>
                topic.
            </p>
            <p> This gives the developer more ability to control the layout and style associated with the options
                when they are using an <code>optionsDataSource</code>.  Below are examples of both the <code>&lt;netui:checkBoxGroup></code>
                and the <code>&lt;netui:radioButtonGroup></code> tags.
            </p>
            <section id="CheckBoxGroup">
                <title>CheckBoxGroup</title>
                <p> This example will create a horizontal layout for a set of checkboxes.  Individual styles
                    will be applied to the labels of the checkbox.  The layout is done using an HTML table.
                </p>
                <p><img src="images/repeatCheckBox.png" alt="CheckBoxGroup with horizontal layout"/></p>
                <p>In the JSP fragment below, the <code>&lt;netui:checkBoxGroup></code> tag is bound
                    to an <code>optionsDataSource</code> in the page flow.  The <code>optionsDataSource</code>
                    is an array of a class that contains the style, label value and option value for each
                    element to be displayed in the group.  Notice that inside the body of the <code>checkBoxGroup</code>
                    all the binding expressions start with <code>${container.item.XXX}</code>.  The body will be
                    repeated for each element in the <code>optionsDataSource</code>.
                </p>
                <p><strong>Note:</strong> The <code>dataSource</code>
                    also directly binds to a page flow variable.  Typically, the <code>dataSource</code>
                    would bind to an <code>actionForm</code> variable.
                </p>
                <source><![CDATA[
<table>
<caption class="normalAttr">CheckBox Group</caption>
<tr><td>
<netui:checkBoxGroup dataSource="pageFlow.results" optionsDataSource="${pageFlow.opts}"
            repeater="true" >
     <netui:span styleClass="${container.item.style}"  value="${container.item.name}" />
     <netui:checkBoxOption value="${container.item.optionValue}" />&nbsp;
</netui:checkBoxGroup>
</td></tr>
</table>
]]></source>
                <p> The following style information is found in the JSP.  These styles affect the
                    presentation of label output.  This is done by setting the styles on the
                    <code>&lt;netui:span></code> tags that act as the labels for the generated
                    checkboxes.
                </p>
                <source><![CDATA[
<style type="text/css">
    .normalAttr {color: #cc0099;font-family:Verdana; font-size:8pt;margin:0,0,0,0;}
    .normal {color: #cc9999;font-family:Verdana; font-size:8pt;margin:0,0,0,0;}
    .normal2 {color: #00cc99;font-family:Verdana; font-size:8pt;margin:0,0,0,0;}
    .normal3 {color: #99cc99;font-family:Verdana; font-size:8pt;margin:0,0,0,0;}
</style>
]]></source>
                <p> Below is the page flow controller that supports the example above.  In the
                    <code>onCreate</code> method, we initialize the <code>optionsDataSource</code>.
                    In addition, we provide a <code>java.lang.String[]</code> that will recieve the
                    results of posting the form back. Finally, an inner class defines a Java bean
                    that contains the information used by the options.
                </p>
                <source>
package repeating;

import org.apache.beehive.netui.pageflow.PageFlowController;
import org.apache.beehive.netui.pageflow.Forward;
import org.apache.beehive.netui.pageflow.annotations.Jpf;

@Jpf.Controller(
    simpleActions={
        @Jpf.SimpleAction(name="begin", path="index.jsp")
    }
)
public class Controller extends PageFlowController
{
    private Options[] opts;
    private String[] results;

    public Options[] getOpts()
    {
        return opts;
    }

    public void setOpts(Options[] opts)
    {
        this.opts = opts;
    }

    public String[] getResults()
    {
        return results;
    }

    public void setResults(String[] resultsOne)
    {
        this.results = resultsOne;
    }

    protected void onCreate()
    {
        // initialize the opts
        opts = new Options[3];
        opts[0] = new Options("Option One","opt-1", "normal");
        opts[1] = new Options("Option Two","opt-2", "normal2");
        opts[2] = new Options("Option Three","opt-3", "normal3");
    }

    /**
     * @jpf:action
     * @jpf:forward name="index" path="Results.jsp"
     */
    @Jpf.Action(
        forwards = {
            @Jpf.Forward(
                name = "index",
                path = "Results.jsp")
        })
    protected Forward post()
    {
        return new Forward("index");
    }

    public static class Options implements java.io.Serializable {
        private String _name;
        private String _optionValue;
        private String _style;

        public Options(String name, String value, String style) {
            _name = name;
            _optionValue = value;
            _style = style;
        }

        public void setName(String name) {
            _name = name;
        }
        public String getName() {
            return _name;
        }

        public void setOptionValue(String optionValue) {
            _optionValue = optionValue;
        }
        public String getOptionValue() {
            return _optionValue;
        }

        public void setStyle(String style) {
            _style = style;
        }
        public String getStyle() {
            return _style;
        }
    }
}
</source>
            </section>
            <section id="RadioButtonGroup">
                <title>RadioButtonGroup</title>
                <p> <strong>Note:</strong> This example is very similar to the previous example using the
                    <a href="#CheckBoxGroup">CheckBoxGroup</a>.  The only real difference is that the
                    layout of the radio buttons is vertical.  For a detailed discussion, you should
                    read that example.
                </p>
                <p><img src="images/repeatRadioButton.png" alt="RadioButtonGroup with vertical layout"/></p>
                <p> Below is a fragment of a JSP that will layout a RadioButtonGroup in a table vertically.
                    All of the options have an individually applied style.  Notice that the
                    <code>repeater</code> attribute is set on the <code>&lt;netui:radioButtonGroup></code>
                    tag to repeat over the items defined in the <code>optionsDataSource</code>.
                </p>
                <source><![CDATA[
<table width="200pt">
    <caption class="normalAttr">RadioButton Group</caption>
    <netui:radioButtonGroup dataSource="pageFlow.results" optionsDataSource="${pageFlow.opts}" repeater="true">
        <tr align="center"><td align="right" width="25%">
            <netui:radioButtonOption value="${container.item.optionValue}" /></td>
            <td align="left"><netui:span styleClass="${container.item.style}" value="${container.item.name}" />
        </td></tr>
    </netui:radioButtonGroup>
</table>
]]></source>
                <p> This example can use the same page flow controller as the previous example with one simple
                    modification.  A radio button group will post back a single value.  By modifying the
                    <code>results</code> property on the page flow controller we convert if from a
                    <code>String[]</code> to just a <code>String</code>.
                </p>
                <source>
    private String results;
    public String getResults()
    {
        return results;
    }
    public void setResults(String resultsOne)
    {
        this.results = resultsOne;
    }
</source>
            </section>
        </section>
        <section id="Select">
            <title>Select</title>
            <p> Repeating in a <code>&lt;netui:select></code> is much different than repeating in
                either the <code>&lt;netui:checkBoxGroup></code> or <code>&lt;netui:radioButtonGroup></code>.
                There is no layout or style information applied to the individual options because typically
                they are displayed as a single select box control inside the browser.
            </p>
            <p> Repeating in the <code>&lt;netui:select></code> enables the developer to control the order
                of the options and to control the HTML <code>&lt;option></code> element rendered
                for each type of option.  A <code>&lt;netui:select></code>
                tag actually creates it's options by iterating over multiple sets of data.  For each unique
                <code>value</code> found, an HTML <code>&lt;option></code> element is rendered.
                The following table
                describes each source of data that can be used to create the output options.
            </p>
            <table>
                <tr><th>Stage Name</th><th>Source property</th><th>Description</th></tr>
                <tr><td><code>option</code></td><td><code>optionsDataSource</code></td>
                    <td>This is an array of some class.  Each element of the array will be output
                    as an option.  Typically the class can just be a <code>String</code> or it may be a Java
                    bean.</td></tr>
                <tr><td><code>default</code></td><td><code>defaultValue</code></td>
                    <td>This is a single value that will be output as an option.  This value is always a
                    <code>String</code></td></tr>
                <tr><td><code>dataSource</code></td><td><code>dataSource</code></td>
                    <td>When the select is rendered, if the variable bound to contains data, it
                    will be added to the options.  This value may be a single <code>String</code>
                    or an array of <code>String</code>s.</td></tr>
                <tr><td><code>null</code></td><td><code>nullableOptionText</code></td>
                    <td>This is a special value that indicates a null value.  You must set
                    the <code>nullable</code> attribute to <code>true</code> to enable this.</td></tr>
            </table>
            <section id="selectExample">
                <title>Select Example</title>
                <p> The following example is a complex Select control <code>&lt;netui:select></code>
                    that controls both the order and how each of the HTML <code>&lt;option></code>
                    elements are rendered.  The source for the JSP is followed by the controller.
                    </p>
                <p><strong>Note:</strong> The select box posts its value back to the page
                    flow. The typical use would be to post a value back through a <code>FormData</code>
                    subclass.
                </p>
                <p><strong>index.jsp</strong></p>
            <source><![CDATA[
<%@ page language="java" contentType="text/html;charset=UTF-8"%>
<%@ taglib uri="http://beehive.apache.org/netui/tags-html-1.0" prefix="netui"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<netui:html>
    <head>
        <title>Order Repeating Select</title>
        <style type="text/css">
            .normalAttr {color: #cc0099;font-family:Verdana; font-size:8pt;margin:0,0,0,0;}
        </style>
    </head>
    <netui:body>
        <h4>Order Repeating Select</h4>
        <p style="color:green">This example demonstrates using a repeating select.
        </p>
        <netui:form action="post">
            <netui:select dataSource="pageFlow.results" defaultValue="default Value"
                    optionsDataSource="${pageFlow.opts}" repeater="true"
                    repeatingOrder="null, default, option" nullable="true">
                <c:if test="${container.metadata.optionStage}">
                    <netui:selectOption repeatingType="option"
                            value="${container.item.optionValue}" styleClass="normalAttr">
                        ${container.item.name}
                    </netui:selectOption>
                </c:if>
                <c:if test="${container.metadata.defaultStage}">
                    <netui:selectOption repeatingType="default"
                            value="${container.item}" styleClass="normalAttr">
                        ${container.item}
                    </netui:selectOption>
                </c:if>
                <netui:selectOption repeatingType="null" value="null-opt"
                        styleClass="normalAttr">
                    [Nothing]
                </netui:selectOption>
            </netui:select>
            <p><netui:button>Submit</netui:button></p>
        </netui:form>
    </netui:body>
</netui:html>
]]></source>
                <p> The <code>&lt;netui:select></code> defines the <code>dataSource</code>,
                    <code>defaultValue</code>, and an <code>optionsDataSource</code>.  These may
                    all be used to add values to the displayed options.  In addition, the "null"
                    option is also set because the <code>nullable</code> attribute is set to <code>true</code>.
                    These are the four sources of options.  The <code>repeater</code> attribute is set
                    to <code>true</code>.  For this reason, the body of the select will be repeated
                    for each option to be rendered.  Finally, the order of the options is specified
                    using the <code>repeatingOrder</code> attribute.  This is a comma separated list
                    of the stage names from the table above.  In this case, the order of the option
                    will be "null", "default, "option" and the "dataSource" will not be displayed.
                </p>
                <source>
&lt;netui:select dataSource="pageFlow.results" defaultValue="default Value"
    optionsDataSource="${pageFlow.opts}" repeater="true"
    <strong>repeatingOrder="null, default, option"</strong> nullable="true">
</source>
                <p> The example uses JSTL logic tags to control the evaluation of expressions for each of the
                    stages.  To include the JSTL core use the following tag library declaration in the JSP.
                </p>
                <source>
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
</source>
                <p>The body of the <code>&lt;netui:select></code> will be evaluted once for each
                    option to be rendered.  In the body, we use the JSTL <code>if</code> tag to control
                    the evalutation of each option.  This is done to prevent expression evaluation errors
                    when the JSP EL expressions are being evalated for each case.  In the <code>container</code>
                    implicit object, the current stage name is exposed within the <code>metadata</code>.  There
                    is a boolean property for each stage that is true only when options for that stage are being
                    generated.  These boolean properties are <code>optionStage</code>, <code>defaultStage</code>,
                    <code>dataSourceStage</code>, and <code>nullStage</code>.
                </p>
                <source>
&lt;c:if test="${container.metadata.optionStage}">
    &lt;netui:selectOption repeatingType="option"
            value="${container.item.optionValue}" styleClass="normalAttr">
        ${container.item.name}
    &lt;/netui:selectOption>
&lt;/c:if>
&lt;c:if test="${container.metadata.defaultStage}">
    &lt;netui:selectOption repeatingType="default"
            value="${container.item}" styleClass="normalAttr">
        ${container.item}
    &lt;/netui:selectOption>
&lt;/c:if>
&lt;netui:selectOption repeatingType="null" value="null-opt"
        styleClass="normalAttr">
    [Nothing]
&lt;/netui:selectOption>
</source>
                <p>
                    The code within the following JSTL <code>if</code> tag will execute only when the 
                    <code>optionsDataSource</code> is being evaluated.  This allows
                    the expressions used to set the properties to be evaluated against a known type and allows
                    other stages to use different types.
                </p>
                <source>
&lt;c:if test="${container.metadata.optionStage}">
    ...
&lt;/c:if>
</source>
                <p> Within the JSTL <code>if</code> tag, there is a <code>&lt;netui:selectOption></code>.
                    The option must identify which stage is being run; this is done by
                    setting the <code>repeatingType</code> attribute to the stage name.  The rest of the
                    values are set using the <code>container</code> implicit object.  This is set to
                    each item defined for that stage.  In this case, it will iterate over the
                    <code>optionsDataSource</code>.
                </p>
                <source>
&lt;netui:selectOption <strong>repeatingType="option"</strong>>
        value="${container.item.optionValue}" styleClass="normalAttr">
    ${container.item.name}
&lt;/netui:selectOption>
</source>
                <p> The option for the nullable value does not contain any expressions and therefore
                    does not appear inside a JSTL <code>if</code> tag.  It will only render an option
                    when the stage becomes <code>null</code> and will be ignored in for all other options.
                </p>
                <source>
&lt;netui:selectOption repeatingType="null" value="null-opt"
        styleClass="normalAttr">
    [Nothing]
&lt;/netui:selectOption>
</source>
                <p>The page flow controller is a simple controller that contains the properties
                    exposing the options and a property that will be set when the form is posted.
                    The options are built in the <code>onCreate</code> method.  For the
                    <code>optionsDataSource</code> each option is defined through an instance
                    of the <code>Options</code> class.
                </p>
                <p><strong>Controller.jpf</strong></p>
                <source>
package select;

import org.apache.beehive.netui.pageflow.PageFlowController;
import org.apache.beehive.netui.pageflow.Forward;
import org.apache.beehive.netui.pageflow.annotations.Jpf;

@Jpf.Controller(
    simpleActions={
        @Jpf.SimpleAction(name="begin", path="index.jsp")
    }
)
public class Controller extends PageFlowController
{
    private Options[] opts;
    private String results;

    public Options[] getOpts()
    {
        return opts;
    }

    public void setOpts(Options[] opts)
    {
        this.opts = opts;
    }

    public String getResults()
    {
        return results;
    }
    public void setResults(String value)
    {
        this.results = value;
    }

    protected void onCreate()
    {
        // initialize the opts
        opts = new Options[3];
        opts[0] = new Options("Option One","opt-1");
        opts[1] = new Options("Option Two","opt-2");
        opts[2] = new Options("Option Three","opt-3");
    }

    @Jpf.Action(
        forwards = {
            @Jpf.Forward(
                name = "index",
                path = "Results.jsp")
        })
    protected Forward post()
    {
        return new Forward("index");
    }

    public static class Options implements java.io.Serializable {
        private String _name;
        private String _optionValue;

        public Options(String name, String value) {
            _name = name;
            _optionValue = value;
        }

        public void setName(String name) {
            _name = name;
        }
        public String getName() {
            return _name;
        }

        public void setOptionValue(String optionValue) {
            _optionValue = optionValue;
        }
        public String getOptionValue() {
            return _optionValue;
        }
    }
}
</source>
            </section>
        </section>
    </body>
</document>