/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * $Header:$
 */
package org.apache.beehive.netui.simpletags.core;

import org.apache.beehive.netui.core.urls.URLRewriterService;
import org.apache.beehive.netui.pageflow.PageFlowContext;
import org.apache.beehive.netui.script.ExpressionEvaluationException;
import org.apache.beehive.netui.simpletags.appender.Appender;
import org.apache.beehive.netui.simpletags.core.services.BehaviorStack;
import org.apache.beehive.netui.simpletags.core.services.ErrorReporter;
import org.apache.beehive.netui.simpletags.core.services.IdScopeStack;
import org.apache.beehive.netui.simpletags.naming.INameInterceptor;
import org.apache.beehive.netui.simpletags.util.ContextUtils;
import org.apache.beehive.netui.util.Bundle;
import org.apache.beehive.netui.util.logging.Logger;

import java.util.List;

abstract public class Behavior
{
    private static final Logger logger = Logger.getInstance(Behavior.class);
    private TagErrorHandling _eh;

    /**
     * Return the name of the tag.  Used by error reporting to get the name of the tag.
     * @return the name of the tag.
     */
    public abstract String getTagName();

    /**
     * This will report an error from a tag.  The error will
     * contain a message.  If error reporting is turned off,
     * the message will be returned and the caller should throw
     * a JspException to report the error.
     * @param message - the message to register with the error
     */
    public void registerTagError(String message, Throwable e)
    {
        TagErrorHandling eh = getErrorHandling();
        TagContext tagCtxt = ContextUtils.getTagContext();
        ErrorReporter er = tagCtxt.getErrorReporter();
        AbstractPageError err = er.registerTagError(message, getTagName(), e);
        eh.setError(err);
    }

    public void registerTagError(AbstractPageError error)
    {
        TagErrorHandling eh = getErrorHandling();
        TagContext tagCtxt = ContextUtils.getTagContext();
        ErrorReporter er = tagCtxt.getErrorReporter();
        AbstractPageError err = er.registerTagError(error);
        eh.setError(err);
    }

    //******************* Lifecycle Methods ************************************

    public final void start()
    {
        TagContext tagCtxt = ContextUtils.getTagContext();
        BehaviorStack stack = tagCtxt.getBehaviorStack();
        stack.push(this);
    }

    /**
     * This method will push the Behavior on the behavior stack.  All overrides of
     * this method should call this method so that the stack is maintained correctly.
     */
    public void preRender()
    {
    }

    /**
     * This method will render the start tag for the markup generated by the behavior.
     * @param appender The <code>Appender</code> to write the markup into.
     */
    abstract public void renderStart(Appender appender);

    /**
     * This method will render teh end tag for the markup generted by the behavior.
     * @param appender The <code>Appender</code> to write the markup into.
     */
    abstract public void renderEnd(Appender appender);

    /**
     * This method will pop the Behavior off of the Behavior stack.  It should always be called when
     * the method is overriden.
     */
    public void postRender()
    {
   }

    public final void terminate()
    {
        TagContext tagCtxt = ContextUtils.getTagContext();
        BehaviorStack stack = tagCtxt.getBehaviorStack();
        Behavior b = stack.pop();
        assert(b != null) : "The Behavior stack is corrupt: Popped a null, expected a '" + getTagName() + "'";
        assert(b == this) : "The Behavior stack is corrupt: Popped:" + b.getTagName() + ", exptected a " +
                getTagName();
    }


    //******************* Protected Methods *************************************

    /**
     * This method will return <code>true</code> if there have been any errors registered on this
     * tag.  Otherwise it returns <code>false</code>
     * @return <code>true</code> if errors have been reported on this tag.
     */
    protected boolean hasErrors()
    {
        return (_eh != null);
    }

    /**
     * This method will write out the <code>String</code> returned by <code>getErrorsReport</code> to the
     * response output stream.
     */
    protected void reportErrors(Appender appender)
    {
        assert(_eh != null);

        TagContext tagCtxt = ContextUtils.getTagContext();
        BehaviorStack behaviorStack = tagCtxt.getBehaviorStack();
        String err = _eh.getErrorsReport(getTagName());
        IErrorCollector ec = (IErrorCollector) behaviorStack.findAncestorWithClass(this, IErrorCollector.class);
        if (ec != null) {
            ec.collectChildError(err);
        }
        else {
            appender.append(err);
        }
    }
    
    /**
     * This method will generate a real id based upon the passed in tagId.  The generated
     * id will be constucted by searching upward for all the script containers that have a
     * scope id set.  These will form a fully qualified id.
     * @param tagId The base tagId set on a tag
     * @return an id value formed by considering all of the scope id's found in the tag hierarchy.
     */
    final protected String getIdForTagId(String tagId)
    {
        if (tagId == null)
            return null;

        TagContext tagCtxt = ContextUtils.getTagContext();
        IdScopeStack idScope = tagCtxt.getIdScopeStack();
        return idScope.getIdForTagId(tagId);
    }

    /**
     * This method walks all of the naming chains and allows them to rewrite the <code>name</code> parameter.
     * After the naming chain processes the name, it will be passed to <code>rewriteName</code> for final processing.
     * If the naming chaing returned from <code>getNamingChain</code> returns null, the name will be passed to
     * <code>rewriteName</code> and returned.  If there is an <code>ExpressionEvaluationException</code> thrown
     * by a <code>INameInterceptor</code>, the error will be registered with the tag and <code>null</code> will
     * be returned.
     * @param name the name to rewrite
     * @return the name after it was passed to all <code>INameInterceptor</code>s in the naming chain.
     * @see #rewriteName
     */
    protected String applyNamingChain(String name)
    {
        assert (name != null) : "The name parameter may not be null";

        List namingChain = getNamingChain();
        if (namingChain == null)
            return rewriteName(name);

        try {
            String newName = name;
            int cnt = namingChain.size();
            for (int i = 0; i < cnt; i++) {
                newName = ((INameInterceptor) namingChain.get(i)).rewriteName(newName, this);
           }

            return rewriteName(newName);
        }
        catch (ExpressionEvaluationException ee) {
            // if there is an expression evaluation error set the error and return null;
            logger.error(Bundle.getString("Tags_ExpressionQualifyingFailure", name));

            // create the expression info an add it to the error tracking
            EvalErrorInfo info = new EvalErrorInfo();
            info.evalExcp = ee;
            info.expression = name;
            info.attr = "dataSource";
            info.tagType = getTagName();

            // report the error
            registerTagError(info);
            return null;
        }
    }

    /**
     * This method will rewrite the name (id) by passing it to the
     * URL Rewritter and getting back a value.
     * @param name the name that will be rewritten
     * @return a name that has been rewritten by the URLRewriterService.
     */
    final protected String rewriteName(String name)
    {
        PageFlowContext pfCtxt = ContextUtils.getPageFlowContext();
        return URLRewriterService.getNamePrefix(pfCtxt.getServletContext(), pfCtxt.getRequest(), name) + name;
    }


    /**
     * Return an <code>List</code> which represents a chain of <code>INameInterceptor</code>
     * objects.  This method by default returns <code>null</code> and should be overridden
     * by objects that support naming.
     * @return an <code>List</code> that will contain <code>INameInterceptor</code> objects.
     */
    protected List getNamingChain()
    {
        return null;
    }

    /**
     * This method will return an ErrorHandling instance.
     * @return TagErrorHandling
     */
    private TagErrorHandling getErrorHandling()
    {
        if (_eh == null) {
            _eh = new TagErrorHandling();
        }
        return _eh;
    }
}
